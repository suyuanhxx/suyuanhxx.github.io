<!doctype html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="长大后能够飞">
<meta property="og:url" content="https://suyuanhxx.github.io/index.html">
<meta property="og:site_name" content="长大后能够飞">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="长大后能够飞">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://suyuanhxx.github.io/"/>





  <title> 长大后能够飞 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">长大后能够飞</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2018/04/23/Java程序员学习Go指南/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/23/Java程序员学习Go指南/" itemprop="url">
                  Java程序员学习Go指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-23T21:06:01+08:00">
                2018-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java程序员学习Go指南"><a href="#Java程序员学习Go指南" class="headerlink" title="Java程序员学习Go指南"></a>Java程序员学习Go指南</h1><p>从事java编码也有三年多了，写的<code>Java</code>代码也很多。<code>Go</code>语言，我是无意间接触到的。在去年12月份左右的时候比特币大涨到1w刀，就想着研究下比特币，而同时有听说Go语言在区块链中非常火爆。就抱着学着看看的心情了解了<code>Go</code>，不知不觉喜欢上<code>Go</code>语言的简介和优雅了。<br><code>Go</code>语言是谷歌推出的一种全新的编程语言，可以在不损失应用程序性能的情况下降低代码的复杂性。<br><code>Go</code>语言的高并发支持，语法的简洁性，指针的自动垃圾回收，可以让开发人员将精力放在业务处理上。<code>Go</code>语言能够将开发人员带入更生层次的去了解底层操作系统，而不仅局限于语言本身。<code>Go</code>语言的”Less is more”，需要在编码过程中去体会这种<strong>设计哲学</strong>！<br>以数据交换为例子，Go语言实现：<br><code>array[i] , array[j] = array[j] , array[i] // Go</code><br>用<code>Java</code>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int temp = array[i];</span><br><span class="line">array[i] = array[j];</span><br><span class="line">array[j] = temp;</span><br></pre></td></tr></table></figure></p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>在语法上<code>Go</code>相对<code>Java</code>有着很多开发人员非常喜欢的特性。可以说这些特性，设计的非常人性化。大大简化了开发人员的工作。语法上从以下四点介绍<code>Java</code>和<code>Go</code>区别</p>
<ol>
<li><p>变量，赋值操作<br>在变量命名规则上<code>Java</code>和<code>Go</code>基本相同，都是大小写字母数字，下划线，不能以数字开头。但在<code>Go</code>中以大写字母开头的变量、方法、函数、结构体都表示<code>public</code>（对所有类可见）类型，小写表示<code>private</code>（本类可见）类型（这里不讨论下划线开头）。而<code>Java</code>中用<code>public</code> <code>private</code>关键字明确表示，没有明确表示的为<code>default</code>（包可见）类型，有比较严格的访问级别。<code>Go</code>语言特意淡化了此点，可以节省很多代码。但也为初学者留下了一些小坑，比如<code>JSON</code>序列化时，属性字段必须大写才能序列化。<br>例如：（<code>Go</code>语言以换行符表示一行代码结束，<code>Java</code>以<code>;</code>表示结束，此法对<code>Go</code>依然适用） </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    type Response struct &#123;</span><br><span class="line">        Message      string        `json:&quot;message&quot;`//将Message字段序列化成JSON中的message</span><br><span class="line">        userName     string        `json:&quot;userName&quot;`//首字母小写，无法被序列化</span><br><span class="line">    &#125;</span><br><span class="line">    ```   </span><br><span class="line">在变量声明赋值上，`Go`语言采用现代化“脚本语言”声明方式。`Go`支持类型自动推断，故在声明变量时可以将变量类型省略。以下一组代码说明变量`a` `b` `c` `d`的多种声明赋值方式，当多个变量赋值时推荐使用最后一种方式，代码量最少。相对于`Java`一行代码只能声明一个变量，要便捷很多。  </span><br><span class="line">函数外部申明必须使用`var`,不要采用`:=`。</span><br></pre></td></tr></table></figure>
<p> var a int<br> a = 10<br> var b int = 10<br> var c = 10<br> d := 10<br> var a, b, c, d = 10<br> a, b, c, d := 10<br> a, b, c, d := 10, 10, 11, 12</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 数据类型  </span><br><span class="line">`Go`语言中的数据类型与`Java`差距比较大，`Go`常用基本数据类型继承了`C/C++`语言特点。  </span><br><span class="line">`Java`中有包装类型，包装类型为对象，`Go`没有此功能。`Go`中还包含一些其他的数据类型简写: `byte` =&gt; `uint8`；`int` =&gt; `uint`；`uint` =&gt; `uint32`或`uint64`；`rune` =&gt; `int32`；`uintptr`表示无符号整型，用于存放一个指针。  </span><br><span class="line">下面表格具体表示了`Go`和`Java`数据类型对比：  </span><br><span class="line"></span><br><span class="line">    | Go        | Java   |值范围 |  说明  |  </span><br><span class="line">    | --------  | :----- |:---  | :---- |  </span><br><span class="line">    |bool      | boolean |true,false     | - |  </span><br><span class="line">    |uint8     | -       |0 ~ 2^7-1      |无符号8位整型  | </span><br><span class="line">    |uint16    | -       |0 ~ 2^15-1     |无符号16位为整型  |  </span><br><span class="line">    |uint32    | -       |0 ~ 2^31-1     |无符号32位整型  | </span><br><span class="line">    |uint64    | -       |0 ~ 2^64-1     |无符号64为整型  | </span><br><span class="line">    |int6      | byte    |-2^7  ~ 2^7-1  |有符号8位整型  |  </span><br><span class="line">    |int16     | short   |-2^15 ~ 2^15-1 |有符号16位整型  |  </span><br><span class="line">    |int32     | int     |-2^31 ~ 2^31-1 |有符号32为整型  |  </span><br><span class="line">    |int64     | long    |-2^63 ~ 2^63-1 |有符号32为整型  |       </span><br><span class="line">    |float32   | float   |IEE754         |32位浮点型    |  </span><br><span class="line">    |float64   | double  |IEE754         |64位浮点型    |  </span><br><span class="line">    |complex64    | -      |             |32位实数和虚数 | </span><br><span class="line">    |complex128   | -      |             |64位实数和虚数 |   </span><br><span class="line">    </span><br><span class="line">    `Go`的数据类型比`Java`更加丰富，但使用起来上两者相差不多。`Go`中没有包装类型，大大减少`Java`中思考使用包装类型还是简单类型的时间。`Go`中也引入了无符号，有符号数据类型的选择。   </span><br><span class="line">    在处理中文字符上，`Go`和`Java`一样方便。  </span><br><span class="line"></span><br><span class="line">3. 指针，`slice`，`map`</span><br><span class="line">    - **指针**  </span><br><span class="line">    `Go`语言仍采用了`C/C++`中的指针，相对于`Java`稍显复杂。但由于`Go`中能够自动垃圾回收，只需要学会灵活使用指针就能够大幅减少内存操作时间，简化代码。可以说Go语言指针是`C/C++`和`Java`的中合。能够享受指针的便捷，同时又省去手动释放指针的麻烦。</span><br><span class="line">    指针变量可以指向任何一个值所在的内存地址。`Go`中使用`*`来声明一个指针，同时也是取指针值操作符。`&amp;`用来取内存地址，16进制，例如`0xc420014608`，不同的机器，不同的环境内存地址都会不同。</span><br></pre></td></tr></table></figure>
<pre><code>var p *int//声明一个指针
a:=10
p=&amp;a //指针赋值
fmt.Println(p)  //打印指针所指向内存地址 0xc420014608
fmt.Println(&amp;a) //a与p所指向内存中同一地址 0xc420014608
fmt.Println(&amp;p) //取变量p地址，会变, 0xc42000e048
fmt.Println(*p) //打印指针内容, 10
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **`slice`**   </span><br><span class="line">`slice`和`Java`中的`List`很像，都是能够自动扩容的数组集合。`Go`中`List`实现了栈和队列的功能，和`Java List`差距比较大。在结构上`Go slice`为动态素组，可以自动根据当前元素和声明的容量进行扩容。使用起来非常方便，但可能会带来性能的消耗，频繁的扩容将使代码运行速率下降。</span><br><span class="line">`slice`有两个额外的属性：`len`（长度），`capacity`（容量）,	`var c = make([]int, capacity)`   </span><br><span class="line">同时需要注意由数组创建的`slice`为数组引用，改变`slice`的值会导致原数组也会发生变化。这种现象在`Go`中非常常见，使用时要格外注意。</span><br></pre></td></tr></table></figure>

var a [4]int      // 数组
a = [4]int{1, 2, 3, 4}// 数组赋值
b := a[1:3] //slice，数组a的引用，从a数组下标1到下标2
b[1] = 5 //a={1,2,5,4}, b={2,5}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而在`Java`中其实也是存在这种现象的，不过Java中“一切皆是对象”的原则，我们在创建一个新的变量或者对象时，都是使用new操作，然后再赋值，所以这种对象引用的该变导致原对象也被改变的情况比较少。变量作为参数时，这种情况发生较多，以下Java代码也时有发生：</span><br></pre></td></tr></table></figure>

List&lt;Integer&gt; a = new ArrayList&lt;&gt;();
a.add(1);
a.add(2);
List&lt;Integer&gt; b = a;
b.add(5);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`slice`有两个非常重要的函数`copy()`、`append()`。`append`函数用于给`slice`追加元素，当slice容量不够时会自动扩容，例如`b = append(b, 3)`；`copy`函数用于将一个数组拷贝到另一个数组，不会自动扩容，例如:</span><br></pre></td></tr></table></figure>

copy(b, []int{7,3,8}) // b={7,3}，由于b的长度只有2，copy只会复制前两位
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- **`map`**  </span><br><span class="line">`map`和`Java`中的`HashMap`就设计思想有很多相似的地方，都是非线程安全的数据结构。`Java`中`HashMap`底层采用数组（`bucket`）+链表+红黑树（红黑树为`JDK1.8`新增部分）的数据结构。都是考虑到`Map`的使用场景，牺牲线程安全提升访问效率的实现方式。并发情况下使用`ConcurrentHashMap`。</span><br><span class="line">`Go map`使用方式相比`Java`更为简单，任何数据类型都可以作为`key`（`Java`中`key`必须为对象，基本数据类型的封装类型才能作为key），例如：</span><br></pre></td></tr></table></figure>

var m map[int]string  // 声明
m[1]=&quot;1&quot;              // 赋值
fmt.Println(m[1])     // 取值
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如何用Go实现一个线程安全的map？最直接的方式就是在map读写的时候加上读写锁...</span><br></pre></td></tr></table></figure>

type ConcurrentHashMap struct {
    lock *sync.RWMutex //Read and write Lock
    cm   map[interface{}]interface{}
}
func (m *ConcurrentHashMap) Get(k interface{}) interface{} {
    m.lock.RLock() //Read Lock
    defer m.lock.RUnlock()
    if val, ok := m.cm[k]; ok {
        return val
    }
    return nil
}
func (m *ConcurrentHashMap) Set(k interface{}, v interface{}) bool {
    m.lock.Lock() // Write Lock
    defer m.lock.Unlock()
    if val, ok := m.cm[k]; !ok {
        m.cm[k] = v
    } else if val != v {
        m.cm[k] = v
    } else {
        return false
    }
    return true
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        `Go map`是`hash`结构的，意味着平均访问时间是O(1)的。同传统的`hashmap`一样，由一个个`bucket`组成，`bucket`内部又由一个指针数组组成。按`key`的类型采用相应的hash算法得到`key`的`hash`值。将`hash`值的低位当作Hmap结构体中buckets数组的index，找到key所在的bucket。将hash的高8位存储在了`bucket`的`tophash`中。注意，这里高8位不是用来当作`key/valu`e在`bucket`内部的`offset`的，而是作为一个主键，在查找时对`tophash`数组的每一项进行顺序匹配的。先比较`hash`值高位与`bucket`的`tophash[i]`是否相等，如果相等则再比较`bucket`的第`i`个的`key`与所给的`key`是否相等。如果相等，则返回其对应的`value`，反之，在`overflow buckets`中按照上述方法继续寻找。  </span><br><span class="line">        ![Hmap结构图](https://tiancaiamao.gitbooks.io/go-internals/content/zh/images/2.2.map.png?raw=true)  </span><br><span class="line">数组，`slice`，`map`的遍历都可直接采用`range`关键字，`foreach`的形式遍历，也可采用`for`循环方式遍历。`foreach`遍历和`Java`相同，都**不宜**在遍历过程中改变原值。   </span><br><span class="line"></span><br><span class="line">4. 方法函数  </span><br><span class="line">对于习惯了Java的开发人员来说，总是会将方法和函数当成一个概念，但在Go中这两个确有一些不同之处。但形式差不多，功能相同。  </span><br><span class="line">    - **函数**，由关键字`func`定义，完成特定功能，可以有多个返回值。例如：`func Add(a int, b int) int &#123; ... &#125;`。形式上和Java有一定差距，功能作用和Java一样。不过Go中能够有多个返回值，这极大的简化了实际功能的完成。一下几个例子说明方法的声明：</span><br></pre></td></tr></table></figure>
</code></pre><p> func Add(a int, b int) int { … }<br> func Sub(a int, b int) (result int) { … }// result 为返回对象，可在方法体中对result直接赋值<br> func Multi(a int, b int)  (int, string) { … } //多个返回值必须是用括号<br> func Divide(a int, b int) (result int, s tring) { … }//如果多个返回值中其中一个有返回值变量，其他的也要有返回值变量</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    - **方法**，函数和方法的定义相差不大。函数一般都是继承某个接口而来，相当于Java中某个类中定义的方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。例如：   </span><br><span class="line">    `func (user *User) getUserName() string &#123; ... &#125;`示例中的`User`为一个结构体，`getUserName`为结构体的一个方法。</span><br><span class="line"></span><br><span class="line">5. 面向对象  </span><br><span class="line">Go中面向对象要简单很多，去除了Java，C/C++中复杂的继承关系，保留了接口`interface`和`struct`。`interface`中包含的是方法，`struct`中只能定义属性。`strcut`能够实现`interface`中的方法（函数）。两者相结合使用实现面向对象的思想，相比Java和C/C++简洁了不少，概念也减少了很多。面向对象的思想还在，仍存在对象关联（父子类）关系。</span><br></pre></td></tr></table></figure>
<pre><code>type People interface {
    getUserName() string
}
type User struct {
    Name string
}
func (user *User) getUserName() string {
    return user.Name
}
func main() {
    var p People
    p = &amp;User{Name: &quot;zhangshan&quot;} //使用User初始化p，p为接口People的实现，只包含方法getUserName()
    fmt.Print(p.getUserName())  // print &quot;zhangshan&quot;
}
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    在`Go`代码中我们要防止接口的滥用，相比`Java`中让人头疼的继承和接口实现，`Go`要相对简单，但我们在使用`interface`时需要考虑是否必要。  </span><br><span class="line"></span><br><span class="line">## 错误处理</span><br><span class="line">`Go`语言中的错误处理相比`Java`中的`try catch`要相对简单一点，但从另一方面Go中的`Errors are values`却又麻烦很多!习惯了`Java`中的`try`抛出异常，`catch`中处理异常的开发人员来说，可能对于`Go`中的`error`和`panic`处理方式会有点不能适应。  </span><br><span class="line">在`Java`中我们通常处理异常（错误）的方式为：将一段可能出错的业务代码使用`try catch`包裹。`try`中进行正常业务逻辑，在`catch`模块对业务逻辑进行补偿操作，事务回滚等，在`finally`模块对资源进行释放。看起来是一段相对严谨的处理逻辑，大多数开发人员处理到这就结束了。但这其中却包含很多不确定性，请看如下代码：</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>try{<br>    A.close();<br>}catch(Exception e){<br>    try{<br>        B.close();<br>    }catch(Exception e){<br>        B.close();<br>    }finally{<br>        B.close();<br>    }<br>}finally{<br>    try{<br>        C.close();<br>    }catch(Exception e){<br>        C.close();<br>    }finally{<br>        C.close();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">对于不确定的值，开发人员都会尝试去捕捉，并做出处理，但上述冗长的代码，感觉非常糟糕，最终的情况可能是ABC三个链接都没法正常关闭。`Java`中`try catch`给我们代码方便的同时，却留下很大的“操作空间”，这可能就陷入了一个死胡同。偷懒的开发人员可能会直接放弃处理，而且大多数开发人员都会如此。因为这实在是太冗长了。在实际开发过程中，catch中往往只做了打印异常的功能，很多开发人员补偿都不会做！  </span><br><span class="line">而`Go`就将这种情况摆在开发人员的面前（`Java`中开发人员能够睁一只眼闭一只眼），你无法忽视这个问题。`Go`的`error`设计是，错误也是一种合法的值——`“Errors are values”`</span><br></pre></td></tr></table></figure></p>
<p>err := Sub()<br>if err != nil { //与常规处理思路相反，优先处理错误<br>    fmt.Print(err)<br>    return err<br>}<br>…//正常业务逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Go`中的异常`panic`会导致整个`Go`程序crash（进一步说明`Go`中的异常必须处理，不可忽略），防止异常导致整个程序崩溃，我们要使用`recover()`来进行恢复。</span><br><span class="line">同时引入关键字`defer`来延迟执行defer后面的函数，非常适合用来处理异常和错误。多条defer函数的处理顺序和声明顺序相反。Go中有很多正确处理错误的实践方式，需要在实际编码过程中体会。  </span><br><span class="line"></span><br><span class="line">## 并发</span><br><span class="line">Go的并发模型设计来自CSP模型。Golang借用CSP模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go语言并没有完全实现了CSP模型的所有理论。仅仅是借用了process和channel这两个概念。相对于Java的并发设计，使用起来要方便很多，因此Go可以轻易的起成千上万个协程（Goroutine）。（这里并不会讲述Go调度器模型）  </span><br><span class="line">Goroutine是实际并发执行的实体，它底层是使用协程(coroutine)实现并发。coroutine是一种运行在用户态的用户线程，类似于greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：</span><br><span class="line">- 用户空间 避免了内核态和用户态的切换导致的成本</span><br><span class="line">- 可以由语言和框架层进行调度</span><br><span class="line">- 更小的栈空间允许创建大量的实例  </span><br><span class="line"></span><br><span class="line">goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。Go中并发编程示例： </span><br><span class="line"></span><br><span class="line">1. 使用`channel`控制并发，`channel`又分为带缓冲`buffer`和不带缓冲`buffer`。不带缓冲的channel不能在同一个gorutine读写，否者发生死锁。带缓冲的channel可以。</span><br></pre></td></tr></table></figure></p>
<pre><code>func main() {
    ch := make(chan int) // 声明一个不带缓冲的channel，ch := make(chan int，2) 带缓冲channel，缓冲为2
    go func() {   // go关键字表示启动一个协程goroutine
        ch &lt;- 1   // channel &lt;- 表示向channel中写数据
    }()
    fmt.Println(&lt;-ch) // i:=&lt;- channle 表示读取channel中的数据到变量i
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用`sync.WaitGroup`控制并发</span><br></pre></td></tr></table></figure>

fun main(){
    var wg sync.WaitGroup
    var urls = []string{&quot;http://www.golang.org/&quot;, &quot;http://www.google.com/&quot;}
    for _, url := range urls {
        wg.Add(1)     //每有一个goroutinie，wg+1
        go func(url string) {
            defer wg.Done()   // 函数最后将该协程goroutine标记为完成
            http.Get(url)
        }(url)
    }
    wg.Wait()  // 等待所有的goroutine完成后再执行下面的代码
}
```
</code></pre><ol>
<li>使用<code>context</code>实现并发控制。<code>context</code>主要是用来处理<code>goroutine</code>中又开启其他<code>gourine</code>，达到跟踪<code>goroutine</code>的解决方案。主要是用来处理多个<code>goroutine</code>之间共享数据，及多个<code>goroutine</code>的管理。</li>
</ol>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p><code>Go</code>语言有指针，也有自动垃圾回收。这一点上与<code>Java</code>一致，都采用了<strong>标记清除</strong>算法，不过<code>Go</code>中还有另外两种垃圾回收算法：位图标记和内存布局，精确的垃圾回收。<br>讨论垃圾回收，就需要知道为什么要有垃圾回收，那就需要先了解系统是如何分配内存。操作系统中有一个内存池。首先，它会向操作系统申请大块内存，自己管理这部分内存。然后，它是一个池子，当上层释放内存时它不实际归还给操作系统，而是放回池子重复利用。这样反复的过程中，内存管理中必然会出现内存碎片问题，当代码中需要申请一个较大的对象时，原用的碎片空间已经不够使用，这就出现了垃圾回收。<br>垃圾回收有着非常长的历史，第一批垃圾回收算法是为单核机器和小内存程序而设计的。那个时候，CPU和内存价格昂贵，而且用户没有太多的要求，即使有明显的停顿也没有关系。这个时期的算法设计更注重最小化回收器对CPU和堆内存的开销。也就是说，除非内存不足，否则GC什么事也不做。而当内存不足时，程序会被暂停，堆空间会被标记并清除，部分内存会被尽快释放出来。<br>分代理论假说，大部分的内存对象“朝生夕死”，它们在分配到内存不久之后就被作为垃圾回收。这就是分代理论假说的基础，它是整个软件产品线 领域最贴合实际的发现。数十年来，在软件行业，这个现象在各种编程语言上表现出惊人的一致性，不管是函数式编程语言、命令式编程语言、没有值类型的编程语言，还是有值类型的编程语言。现代垃圾回收器基本上都是基于分代算法。分代回收器可以加入其它各种特性，一个现代回收器将会集并发、并行、压缩和分代于一身。<br>例如Java中JVM的GC分为“年轻代”和“老年代”，“年轻代”的对象大多“朝生夕死”，能够存活下来的对象会放到老年代中。是典型的分代回收器。<br>下面简单分析集中垃圾回收算法：    </p>
<ol>
<li><p>标记清除算法<br>我们都知道标记清除算法会“stop the world”。内存单元并不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，也就是 STW，转而执行垃圾回收程序。<br>该算法中有一个标记初始的root区域，以及一个受控堆区。root区域主要是程序运行到当前时刻的栈和全局数据区域。在受控堆区中，很多数据是程序以后不需要用到的，这类数据就可以被当作垃圾回收了。判断一个对象是否为垃圾，就是看从root区域的对象是否有直接或间接的引用到这个对象。如果没有任何对象引用到它，则说明它没有被使用，因此可以安全地当作垃圾回收掉。<br>标记清扫算法分为两阶段：标记阶段和清扫阶段。标记阶段（Go采用的是三色标记法），从root区域出发，扫描所有root区域的对象直接或间接引用到的对象，将这些对上全部加上标记。在回收阶段，扫描整个堆区，对所有无标记的对象进行回收。）<a href="https://github.com/KeKe-Li/For-learning-Go-Tutorial/blob/master/src/spec/02.0.md" target="_blank" rel="noopener">more</a><br><img src="https://raw.githubusercontent.com/KeKe-Li/For-learning-Go-Tutorial/master/src/images/1.gif" alt=""></p>
</li>
<li><p>位图标记和内存布局<br>既然垃圾回收算法要求给对象加上垃圾回收的标记，显然是需要有标记位的。一般的做法会将对象结构体中加上一个标记域，一些优化的做法会利用对象指针的低位进行标记，这都只是些奇技淫巧罢了。Go没有这么做，它的对象和C的结构体对象完全一致，使用的是非侵入式的标记位.</p>
</li>
<li><p>精确垃圾回收<br>通过定位对象的类型信息，得到该类型中的垃圾回收的指令码，通过一个状态机解释这段指令码来执行特定类型的垃圾回收工作。对于堆中任意地址的对象，找到它的类型信息过程为，先通过它在的内存页找到它所属的MSpan，然后通过MSpan中的类型信息找到它的类型信息。<a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/06.2.html" target="_blank" rel="noopener">more</a>  </p>
</li>
</ol>
<h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p><code>Go</code>作为一个现代化后端程序语言，搭建微服务架构当然也是没有任何问题的。Go通常采用<code>Go-Kit</code>作微服务框架，<code>Java</code>通常采用<code>Spring Cloud</code>做微服务架构。<br>微服务的架构主要关键包含以下几点：</p>
<ol>
<li><p><strong>服务拆分</strong><br>服务拆分粒度主要看具体业务需求，不易太宽泛，也最好不要太细，不然就会产生几十个微服务，维护成本较大。  </p>
</li>
<li><p><strong>服务治理（服务注册发现）</strong><br>服务注册发现又分为两种：</p>
<ul>
<li>客户端发现模式<br>当使用客户端发现模式时，客户端负责决定相应服务实例的网络位置，并且对请求实现负载均衡。客户端从一个服务注册服务中查询，其中是所有可用服务实例的库。客户端使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。服务实例的网络位置是在启动时注册到服务注册表中，并且在服务终止时从注册表中删除。服务实例注册信息一般是使用心跳机制来定期刷新的。Netflix Eureka是一个服务注册表，为服务实例注册管理和查询可用实例提供了REST API接口。Netflix Ribbon是一种IPC客户端，与Eureka合同工作实现对请求的负载均衡。</li>
<li><p>服务端发现模式<br>客户端通过负载均衡器向某个服务提出请求，负载均衡器向服务注册表发出请求，将每个请求转发往可用的服务实例。跟客户端发现一样，服务实例在服务注册表中注册或者注销。</p>
<p>Java微服务实践中通常使用<code>Spring Cloud</code>框架，使用<code>Eureka</code>作为微服务的服务注册表，spring封装了<code>Eureka</code>，让Eureka即作服务转发又作服务注册表。<br>Go中可以使用<code>Consul</code>（一个用于发现和配置的服务。提供了一个API允许客户端注册和发现服务。Consul可以用于健康检查来判断服务可用性），<code>etcd</code>(一个高可用，分布式的，一致性的，键值表，用于共享配置和服务发现。两个著名案例包括Kubernetes和Cloud Foundry) </p>
</li>
</ul>
</li>
<li><p><strong>远程调用RPC</strong><br>在<code>RPC</code>方面<code>Java</code>和<code>Go</code>均可采用<code>GRPC</code>、<code>Apache thrift</code>或者直接采用<code>Restful</code>风格的<code>Http</code>请求。<code>Java</code>也可采用<code>dubbo</code>封装的<code>RPC</code>方式  </p>
</li>
<li><p><strong>高可用，负载均衡</strong><br>服务治理能够在服务与服务之间时间负载均衡。<br><code>HTTP</code>反向代理和负载据衡器（例如<code>NGINX</code>）可以用于服务发现负载均衡器。服务注册表可以将路由信息推送到<code>NGINX</code>，激活一个实时配置更新；例如，可以使用 <code>Consul Template</code>。<code>NGINX Plus</code>支持额外的动态重新配置机制，可以使用<code>DNS</code>，将服务实例信息从注册表中拉下来，并且提供远程配置的<code>API</code>。</p>
</li>
<li><p><strong>网关，路由追踪</strong><br>理论上说，一个客户端可以直接给多个微服务中的任何一个发起请求。每一个微服务都会有一个对外服务端(<code>https://serviceName.api.company.name</code>)。这个URL可能会映射到微服务的负载均衡上，它再转发请求到具体节点上。<br>通常来说，一个更好的解决办法是采用<code>API Gateway</code>的方式。<code>API Gateway</code>是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade模式很像。<code>API Gateway</code>封装内部系统的架构，并且提供API给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。<br><code>Java</code>中通常使用<code>zuul</code>来搭建服务器网关。  </p>
</li>
</ol>
<hr>
<p>最后给大家推荐我的几个Repo</p>
<ul>
<li><a href="https://github.com/suyuanhxx/blockchain" target="_blank" rel="noopener">blockchain</a>，简易区块链demo</li>
<li><a href="https://github.com/suyuanhxx/crawler" target="_blank" rel="noopener">crawler</a>，开车爬图专用（好用的repo没人star）</li>
<li><a href="https://github.com/suyuanhxx/go-kit-demo" target="_blank" rel="noopener">go-kit-demo</a>，Go微服务demo</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2018/02/03/微服务发版总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/03/微服务发版总结/" itemprop="url">
                  微服务发版总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-03T13:48:18+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周四版本上线，我的服务有几次重复发版，负责人让我总结下原因，感觉一阵蛋疼。</p>
<h2 id="基金基础服务发版过于频繁的总结"><a href="#基金基础服务发版过于频繁的总结" class="headerlink" title="基金基础服务发版过于频繁的总结"></a>基金基础服务发版过于频繁的总结</h2><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li>思考问题不全面<ul>
<li>在编写代码过程中，开发人员想到的场景可能不全。往往都会出现某些条件没有考虑的清形。例如：在飞鱼3.7.1基金终止上市该功能开发中，我只考虑到基金终止和正常上市的情况。而在上线之后，测试人员发现将“转型”过的基金（该基金由终止状态转换为正常上市交易）也设置为终止。导致上线之后需要修复该功能。</li>
<li>测试环境只包含线上很少的基金数据，导致自测和测试都无法发现场景分支。</li>
<li>业务能力不够。对基金业务仍不是非常了解，往往容易出现业务场景思考不足，导致代码容易出bug。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>测试覆盖不全面<ul>
<li>自测不到位。测试用例编写不够，很多时候只编写了少部分测试用例，只通过主功能，未考虑边界条件，同时未写测试用例分支也为考虑。</li>
<li>测试人员测试粒度不够。有时代码优化功能，或者以前已经测试过通过的功能，做出优化重构之后未提交给测试，导致测试粒度不够，上线之后才发现bug。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>“环境问题”<br>测试数据与生产环境有一定差距。目前由于一些原因（恒生数据配置原因）导致测试环境数据和生产环境数据还是有很大的差距，会导致“环境问题”（测试环境无bug，生产上有bug，反之）。例如，代销基金列表，测试环境只有80只基金左右，而线上有将近2300只基金。而根据我经验，有时每只基金都可能会出现一种完全不同的情况，所以有时测试也很难测全面。  </li>
</ol>
<hr>
<ol>
<li>兼容性问题（设计缺陷）<ul>
<li>由于飞鱼项目在app项目进度不一致，有时容易出现最开始设计的功能已经不再适用app的需求，而在上线之前未评估到这一情况，就会导致在上线之后才发现问题。同时前面设计的功能开发人员认为修修改改就能适用app（或者飞鱼），但实际情况可能不理想。</li>
<li>由于OMS功能比较落后，而我们几个产品有时意见也很难统一，各自都有自己的特色。导致我们的设计很难顾全所有的产品。例如精选基金，app要求即按月份又要同时满足不同客户端的定制需求。而在前期的设计中没考虑不同客户端的问题，故在后期维护中难度较大。容易产生bug，不过后面经过协调产品达成一致。</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li>代码缺陷<ul>
<li>空指针问题。编写代码时非常容易出现的一个问题，代码判断不全面导致</li>
<li>超时问题。接口比较慢导致超时，而未做任何处理，这一般是开发人员无法意料到的问题。恒生接口和巨灵数据库sql查询等容易出现超时。</li>
<li>异常补偿机制。开发人员很多时候对可能出现bug的代码未做异常处理，而有些则是只是做了简单的try catch，没有异常补偿，只能保证前端接口的正常访问，却不能修复数据。例如组合收益率走势图bug等。</li>
<li>数据源问题。数据源的切换没有做更加详细的测试，对源数据未加工，导致界面显示错误。例如货币基金7日年化异常，持仓收益率未计算等bug。</li>
</ul>
</li>
</ol>
<h3 id="总结（改进）"><a href="#总结（改进）" class="headerlink" title="总结（改进）"></a>总结（改进）</h3><ol>
<li>加强单元测试，自测。养成编写单元测试的习惯，不仅如此，还要养成对同一个场景编写尽可能全的单元测试用例，各个分支条件要覆盖到，还要对考虑边界条件测试用例的编写。多线程场景条件写的测试用例等。养成自测习惯。再小的功能点都需要编写测试用例。<strong>提高对测试用力的重视</strong>。</li>
<li><strong>提高自身意识，需提高对代码上线的严肃态度</strong>。目前由于上线流程简单，而微服务往往上线牵涉面比较广，而我们目前用户较少，上线发生的服务中断等用户反馈较少，导致开发人员普遍没有高可用意识，上线比较随意。同时测试或者其他人员催促较急，代码未经过完整的测试就上线，这不利于培养上线严肃的态度。但这需要把控个度。<em>培养以用户为中心的思维习惯，能够提高开发人员对代码上线造成的服务不可用带来的思考。</em></li>
<li>加强业务知识，业务理解。</li>
<li>做好沟通交流。对优化的代码，功能点要及时发聩给测试人员回归测试。开发人员之间也要多保持交流，可以<strong>交换大家对业务的理解。也可提高编码能力。</strong></li>
<li>加强自身编码能力。对于边界条件的思考和复杂场景的处理，要做到尽善尽美。</li>
<li>代码审查。<strong>定期代码审查或者代码（技术）分享</strong>能够提高大家能力，减少bug。分享不一定是开会，好的代码或者好的idea都可以分享。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2018/01/23/分布式锁/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/23/分布式锁/" itemprop="url">
                  分布式锁
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-01-23T19:51:32+08:00">
                2018-01-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="以前写过一篇关于锁和分布式相关的文章，但当时对于锁和分布式的理解都不是很透彻，只是描述了一些简单的基本现象，又或者是一些别人的理解搬过来而已。而今随着能力的加强，见识的加深，有了自己的理解和解释。"><a href="#以前写过一篇关于锁和分布式相关的文章，但当时对于锁和分布式的理解都不是很透彻，只是描述了一些简单的基本现象，又或者是一些别人的理解搬过来而已。而今随着能力的加强，见识的加深，有了自己的理解和解释。" class="headerlink" title="以前写过一篇关于锁和分布式相关的文章，但当时对于锁和分布式的理解都不是很透彻，只是描述了一些简单的基本现象，又或者是一些别人的理解搬过来而已。而今随着能力的加强，见识的加深，有了自己的理解和解释。"></a>以前写过一篇关于锁和分布式相关的文章，但当时对于锁和分布式的理解都不是很透彻，只是描述了一些简单的基本现象，又或者是一些别人的理解搬过来而已。而今随着能力的加强，见识的加深，有了自己的理解和解释。</h2><ol>
<li>为什么要有锁<br> 阮一峰的博客中用“门上的锁”来解释代码中的锁，以及为什么需要这样一把锁。非常的形象。如果没有锁，就会造成大家都能不能进去。锁是竞争资源的关键。有了锁才能保证唯一的资源被正常合理的使用，不造城拥挤和等待。代码中也是这样。例如多个线程同时访问某个接口（这里以生成密钥串接口<code>keyGenerateImpl</code>为例，每生成一次密钥串，上一个密钥串就失效），如果没有锁就会造成多个线程同时去访问生成密钥串接口，而这几个线程都拿着生成好的密钥去做其他操作时，发现自己的密钥失效了，这个时候才发现这<code>n</code>个线程中只有一个线程能够访问成功。这显然不是我们希望得到的结果！如果在这个获取密钥接口上加一把锁，而锁一次只能一个线程拥有，那就能解决这个问题。</li>
<li>什么是分布式锁<br> 现在大多是项目都采用微服务的，分布式的方式部署，对单个机器上的方法接口加锁已经失去了意义！同一时间有100个请求，服务器负载均衡的方式部署，就会有50个请求落在服务器A，50个请求落在服务器B上，还是会造成各个请求同时生成不用的密钥，100个请求中还是有99个失效。这就是分布式情况下以前的代码锁（专指关键字<code>synchronized</code>,<code>Lock</code>）就没什么用了。如何解决该问题，就需要一个中心节点（暂且称作中心节点）来维护这种关系，也就是分布式锁。分布式锁能够实现多个服务器的统一，AB…两台服务器上都只有这一把锁，有这把锁来控制请求是否能够获得密钥。</li>
<li>怎么实现分布式锁<br> 可供选择的分布式中心节点方案很多，包括<code>redis</code>，<code>zookeeper</code>，<code>mq</code>等都适合作为中心节点，即锁的存放地方。<br> 具体细节：100个请求分别落在服务器AB上，AB两台服务器这时都会访问中心节点服务器，A服务器上的某个请求获取到<code>zookeeper</code>上的瞬时节点，说明该请求<code>request1</code>去到了锁，其他99个请求等待。这里需要特别说明，虽然请求是同时发出的，但到达中心节点的时刻不同，谁先到达谁获得该瞬时节点。获得瞬时节点的<code>request1</code>拿到密钥完成业务逻辑之后释放该瞬时节点，然后剩余的99个请求再去竞争锁。<br> 代码示例如下（以<code>redis</code>作为中心节点，在<code>redis</code>中可将<code>key</code>理解为<code>zookeeper</code>瞬时节点）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param userId</span><br><span class="line"> * @param acquireLockTimeout 获取锁超时时间 单位：s</span><br><span class="line"> * @param lockTimeout        锁过期时间 单位：s</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private String acquireLockWithTimeout(String requestId, long acquireLockTimeout, long lockTimeout) &#123;</span><br><span class="line">    String identifier = UUID.randomUUID().toString();</span><br><span class="line">    String lockName = String.format(LOCK_NAME, requestId);</span><br><span class="line">    long end = System.currentTimeMillis() + acquireLockTimeout * 1000;</span><br><span class="line">    while (System.currentTimeMillis() &lt; end) &#123;</span><br><span class="line">        if (redisTemplate.opsForValue().setIfAbsent(lockName, identifier)) &#123;</span><br><span class="line">            expire(lockName, lockTimeout, TimeUnit.SECONDS);</span><br><span class="line">            return identifier;</span><br><span class="line">        &#125;</span><br><span class="line">        if (redisTemplate.getExpire(lockName) == -1) &#123;</span><br><span class="line">            expire(lockName, lockTimeout, TimeUnit.SECONDS);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">            log.error(&quot;acquireLockWithTimeout thread sleep error!&quot;, ie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>acquireLockWithTimeout</code>该方法属于超时锁，在<code>acquireLockTimeout</code>时间段内会不断的重试获取锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param userId</span><br><span class="line"> * @param waitTime    等待时间 单位：s</span><br><span class="line"> * @param lockTimeout 锁过期时间 单位：s</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private String acquireLockAndWait(String requestId, long waitTime, long lockTimeout) &#123;</span><br><span class="line">    String identifier = UUID.randomUUID().toString();</span><br><span class="line">    String lockName = String.format(LOCK_NAME, requestId);</span><br><span class="line">    if (redisTemplate.opsForValue().setIfAbsent(lockName, identifier)) &#123;</span><br><span class="line">        expire(lockName, lockTimeout, TimeUnit.SECONDS);</span><br><span class="line">        return identifier;</span><br><span class="line">    &#125;</span><br><span class="line">    if (redisTemplate.getExpire(lockName) == -1) &#123;</span><br><span class="line">        expire(lockName, lockTimeout, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        Thread.sleep(waitTime * 1000);</span><br><span class="line">    &#125; catch (InterruptedException ie) &#123;</span><br><span class="line">        log.error(&quot;acquireLockAndWait thread sleep error!&quot;, ie);</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>acquireLockAndWait</code>该方法属于获取锁，当获取不到锁时等待，等待期间不会去尝试获取锁。<br>一定要释放锁，设置自动过期锁或者手动释放锁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 释放锁，只有锁内容符合时才会释放</span><br><span class="line">*</span><br><span class="line">* @param requestId     用户id</span><br><span class="line">* @param identifier 锁内容</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">private boolean releaseLock(String requestId, String identifier) &#123;</span><br><span class="line">   String lockName = String.format(LOCK_NAME, requestId);</span><br><span class="line">   while (true) &#123;</span><br><span class="line">       if (identifier.equals(redisTemplate.opsForValue().get(lockName))) &#123;</span><br><span class="line">           redisTemplate.delete(lockName);</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       break;</span><br><span class="line">   &#125;</span><br><span class="line">   return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://gist.github.com/suyuanhxx/91bc5d70a025a72f3d064bcca5fd20ea" target="_blank" rel="noopener">完整代码清单</a><br><a href="https://gist.github.com/suyuanhxx/baf7f049381426dc1ff9bd7d376f9164" target="_blank" rel="noopener">测试用例</a><br>注意测试用例的编写</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/12/31/2017个人总结/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/31/2017个人总结/" itemprop="url">
                  2017年个人总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-31T14:27:05+08:00">
                2017-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2017年个人总结"><a href="#2017年个人总结" class="headerlink" title="2017年个人总结"></a>2017年个人总结</h2><p>2017年是我的本命年，可以说过的非常充实。不是浑浑噩噩的一年，有着很多如数家珍的回忆；也有一些时光飞快的感慨，不及回首。  </p>
<ul>
<li>1月，和我哥一起创办湖北忠仁信法律咨询服务有限公司。一月份有大量的时间是和小伙伴一起讨论企业未来规划，发展道路，理念。  </li>
<li>2月，分期买了一台mac pro。  </li>
<li>3月，几乎每个周末的都呆在浦东新区图书馆，效率很低，准备换一个工作。  </li>
<li>4月，第一次去迪士尼。使用nodejs完成了<a href="http://zrxlaw.com" target="_blank" rel="noopener">忠仁信的官网</a>，大部分自己设计。现在想来赞叹自己的坚持。  </li>
<li>5月，在我哥的婚礼上当伴郎，感觉我们都长大了。  </li>
<li>6月，在新的工作环境中努力工作，去梅赛德斯奔驰文化中心看了音乐剧《风云再起-雄霸天下》。  </li>
<li>7月，看完了《三体》第一部，完整看完了《三国演义》。  </li>
<li>8月，看完了《三体·黑暗森林》《三体·死神降临》。  </li>
<li>9月，搬家，和同学一起单车游玩滨江大道。  </li>
<li>10月，可爱的小侄女出世了，还完成了另外一件大事……。  </li>
<li>11月，非常强烈的思想斗争，内心充满负能量。思考，探索。  </li>
<li>12月，看窗外云卷云舒。  </li>
</ul>
<h2 id="2018年计划"><a href="#2018年计划" class="headerlink" title="2018年计划"></a>2018年计划</h2><p><strong>立flag</strong>，脚站的很稳。</p>
<ul>
<li>坚持锻炼身体。</li>
<li>旅游。</li>
<li>交更多的朋友，认识大佬。</li>
<li>阅读更多的书籍，《围城》等。</li>
<li>开拓眼界，视野，认识。</li>
<li>更加成熟，提升气质。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/11/22/solr/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/22/solr/" itemprop="url">
                  solr实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-22T22:22:28+08:00">
                2017-11-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="solr实践"><a href="#solr实践" class="headerlink" title="solr实践"></a>solr实践</h1><p>Solr是一个高性能，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言。实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ol>
<li>文档通过Http利用XML 加到一个搜索集合中。</li>
<li>查询该集合也是通过http收到一个XML/JSON响应来实现。</li>
<li>它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，</li>
<li>提供一套强大Data Schema来定义字段，类型和设置文本分析，提供基于Web的管理界面等。</li>
</ol>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>索引，用来检索关键字</li>
<li>分词，</li>
<li>“定时器”，定时“全量更新”和“重建索引”，防止数据不一致，或者查询效率低。</li>
</ol>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><ol>
<li>solr服务器搭建搭建部署，配置</li>
<li>将数据库中的查询内容导入到solr索引库，这里使用的是solrj的客户端实现的。</li>
<li>建立搜索服务，供客户端调用。调用solr，查询内容，这中间有分页功能的实现等。solr高亮显示的实现。</li>
<li>客户端接收页面的请求参数，调用搜索服务，进行搜索。</li>
</ol>
<h2 id="solr相关命令"><a href="#solr相关命令" class="headerlink" title="solr相关命令"></a>solr相关命令</h2><ol>
<li>启动  <code>./bin/solr start</code> </li>
<li>删除所以索引数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;delete&gt;&lt;query&gt;*:*&lt;/query&gt;&lt;/delete&gt;</span><br><span class="line">&lt;commit/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/04/02/清明节祭文/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/02/清明节祭文/" itemprop="url">
                  清明节随手记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-02T16:09:42+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>清明节时节雨纷纷，路上行人欲断魂。今年清明节没有雨，天气反而格外的好，但看到听到很多人回家了，而我已经有好几年没有回家给外公扫墓祭拜。天气这么好都没有回家，还是忍不住有些伤感。</p><br><p>说起外公，毫无疑问是我成长过程中影响最大的人。</p><br><p>最令我记忆犹新的仍然是我小时候的顽皮。有一次外公翘二郎腿，我也学着外公也翘起二郎腿。外公换左腿，我换左腿；外公换右腿，我跟着换右腿。外公教训我小孩子要“坐有坐相”，“坐姿要正”，我就反驳“你都能翘，为啥我不能”，外公说我这么小就不学乖，但拿我没辙。外公那种时而严肃，时而和蔼，琢磨不透的性格。现在想起来我的很多脾气秉性大多都是学自外公吧。外公是一个令身边人都很敬仰的人，值得我去学习。</p><br>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2017/04/02/清明节祭文/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/03/26/Java死锁分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/26/Java死锁分析/" itemprop="url">
                  Java死锁分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-26T15:01:53+08:00">
                2017-03-26
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <ul>
<li>多线程死锁的产生：</li>
<li>当一个线程永远地持有一个锁，并且其他线程都尝试去获得这个锁时，那么它们将永远被阻塞。</li>
<li>如果线程A持有锁L并且想获得锁M，线程B持有锁M并且想获得锁L，那么这两个线程将永远等待下去，这种情况就是最简单的死锁形式。</li>
<li>检测死锁产生：</li>
<li>1、先找到可疑进程，jps获得当前Java虚拟机进程的pid</li>
<li>2、使用jstack打印堆栈，jstack打印内容的会报告发现了一个死锁，同时也能够通过分析waiting，locked得出结论
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2017/03/26/Java死锁分析/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/03/18/《spring技术内幕》/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/18/《spring技术内幕》/" itemprop="url">
                  《spring技术内幕》
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-18T13:41:27+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><p>Spring core</p>
<h2 id="IoC、AOP是spring的核心"><a href="#IoC、AOP是spring的核心" class="headerlink" title="IoC、AOP是spring的核心"></a>IoC、AOP是spring的核心</h2><p>IoC容器管理POJO对象，以及它们相互之间的耦合关系，是数据资源可用简单的Java语言来描述和抽象<br>AOP以动态非侵入式的方式来增强服务的功能<br>（Spring架构图）</p>
<p>IoC容器：BeanFactory，ApplicationContext<br>BeanFactory和FactoryBean的区别，简而言之，BeanFactory是加载的容器，加载一切的BEAN，而FactoryBean用于创建代理类</p>
<p>Spring请求调用过程</p>
<ol>
<li>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</li>
<li>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：<br>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息<br>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等<br>数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等<br>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li>
<li>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</li>
<li>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</li>
<li>ViewResolver 结合Model和View，来渲染视图</li>
<li>将渲染结果返回给客户端。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/03/09/分布式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/09/分布式/" itemprop="url">
                  分布式技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-09T13:20:13+08:00">
                2017-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>中心化<br>中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之间的一致性。<br>去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商达到一致。</p>
<p>Zookeeper：<br>用Paxos协议选择Leader，用Lease协议控制数据是否有效。用Quorum协议把Leader的数据同步到follow。</p>
<p>MySql：<br>MySQL的主从库设计也是基于日志。从库只需通过回放主库的日志，就可以实现与主库的同步。由于从库同步的速度与主库更新的速度没有强约束，这种方式只能实现最终一致性。<br>读写分离，主从同步<br>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2017/03/09/分布式/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://suyuanhxx.github.io/2017/03/02/nodejs-express学习笔记/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Huangxiaoxu">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="长大后能够飞">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="长大后能够飞" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/02/nodejs-express学习笔记/" itemprop="url">
                  nodejs express学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-02T21:06:52+08:00">
                2017-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>　　</p><p>打算用Nodejs和Express做一个简单的项目，从零开始一步一步学习nodejs。</p><p></p>
<h2 id="nodejs-mongodb分页实现"><a href="#nodejs-mongodb分页实现" class="headerlink" title="nodejs, mongodb分页实现"></a><code>nodejs</code>, <code>mongodb</code>分页实现</h2><ol>
<li><p>使用<code>mongoose</code> <code>skip</code>方法实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">exports.pagingBySkip = function (model, pageIndex, pageSize, callback) &#123;</span><br><span class="line">    var modelSchema = mongoose.model(model);</span><br><span class="line">    var query = modelSchema.find();</span><br><span class="line">    if (Number(pageIndex) &gt;= 1 &amp;&amp; Number(pageSize) &gt;= 1) &#123;</span><br><span class="line">        query.skip((pageIndex - 1) * Number(pageSize));</span><br><span class="line">        query.limit(Number(pageSize));</span><br><span class="line">    &#125;</span><br><span class="line">    query.exec(function (err, docs) &#123;</span><br><span class="line">        callback(err, docs);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据ObjectId获取最后一个，然后获取这个id的下一页，需要实现两个方法:</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2017/03/02/nodejs-express学习笔记/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Huangxiaoxu" />
          <p class="site-author-name" itemprop="name">Huangxiaoxu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Huangxiaoxu</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  




  
  

  

  

  

  


</body>
</html>
